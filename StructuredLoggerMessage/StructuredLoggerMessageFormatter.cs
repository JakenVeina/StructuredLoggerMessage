using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace Microsoft.Extensions.Logging.Structured
{
    /// <summary>
    /// Provides methods for generating text-log messages at runtime, in a high-performance manner,
    /// by pre-parsing a given format string.
    /// </summary>
    [DebuggerDisplay("{{{" + nameof(OriginalFormat) + "}}}")]
    public class StructuredLoggerMessageFormatter
    {
        /// <summary>
        /// The value name that should be provided to structural loggers, along with the value of <see cref="OriginalFormat"/>.
        /// </summary>
        public const string OriginalFormatValueName
            = "{OriginalFormat}";

        /// <summary>
        /// Constructs a new <see cref="StructuredLoggerMessageFormatter"/> instance, by parsing a given format string.
        /// 
        /// Format strings should follow the same formatting as <see cref="string.Format(string, object[])"/>, except that interpolated values within the string may be given text names, rather than simply identified by index. However, this does impose the limitation that value parameters must be given in the order that they appear in the format string.
        /// </summary>
        /// <param name="formatString">The format string to be parsed.</param>
        /// <exception cref="MalformedFormatStringException">Throws if <paramref name="formatString"/> is malformed.</exception>
        /// <returns>A new formatter that will generate messages, based on <paramref name="formatString"/>.</returns>
        public static StructuredLoggerMessageFormatter CreateFromFormatString(string formatString)
        {
            var messagePieces = new List<string>();
            var valueNames = new List<string>();

            foreach(var (piece, isValueName) in EnumerateFormatPieces(formatString))
                (isValueName ? valueNames : messagePieces).Add(piece);

            return new StructuredLoggerMessageFormatter(
                messagePieces,
                formatString,
                valueNames);
        }

        private StructuredLoggerMessageFormatter(
            IReadOnlyList<string>   messagePieces,
            string                  originalFormat,
            IReadOnlyList<string>   valueNames)
        {
            _messagePieces  = messagePieces;
            _originalFormat = originalFormat;
            _valueNames     = valueNames;
        }

        /// <summary>
        /// The original format string that was parsed to construct this formatter.
        /// 
        /// This value should be included in structural-logger state models, under the name <see cref="OriginalFormatValueName"/>,
        /// in compliance with messages generated by <see cref="LoggerMessage"/>.
        /// </summary>
        public string OriginalFormat
            => _originalFormat;

        /// <summary>
        /// The names of log values to be formatted, parsed out of <see cref="OriginalFormat"/>, in the order in which they appear within <see cref="OriginalFormat"/>.
        /// </summary>
        public IReadOnlyList<string> ValueNames
            => _valueNames;

        /// <summary>
        /// Generates a text message for logging, using the given set of data values.
        /// </summary>
        /// <typeparam name="TValues">The type of object containing the values to be formatted.</typeparam>
        /// <param name="values">The values to be formatted.</param>
        /// <exception cref="ArgumentException">Throws if the number of values in <paramref name="values"/> is less than the number of values in <see cref="ValueNames"/>.</exception>
        /// <returns>The message text generated by formatting the values within <paramref name="values"/> into <see cref="OriginalFormat"/>.</returns>
        /// <remarks>
        /// This method is defined as generic to allow for high-performance scenarios, where <paramref name="values"/> may be a value type, allocated on the stack, without the need for a boxing cast.
        /// 
        /// Also, note that if <paramref name="values"/> contains more values than <see cref="ValueNames"/>, the extra values in <paramref name="values"/> will simply be ignored.
        /// </remarks>
        public string Format<TValues>(TValues values)
            where TValues : IReadOnlyList<object?>
        {
            if (values.Count < _valueNames.Count)
                throw new ArgumentException($"Not enough values supplied. Excepted {_valueNames.Count}, got {values.Count}", nameof(values));

            var formatBuilder = new StringBuilder(OriginalFormat.Length * 2);

            for(var i = 0; i < _valueNames.Count; ++i)
            {
                formatBuilder.Append(_messagePieces[i]);
                formatBuilder.Append(values[i]?.ToString() ?? "null");
            }
            formatBuilder.Append(_messagePieces[_messagePieces.Count - 1]);

            return formatBuilder.ToString();
        }

        private static IEnumerable<(string piece, bool isValueName)> EnumerateFormatPieces(string formatString)
        {
            var pieceBuilder = new StringBuilder(formatString.Length);

            var isValueName = false;
            for(var i = 0; i < formatString.Length; ++i)
            {
                if (formatString[i] == '{')
                {
                    var j = i + 1;
                    if ((j < formatString.Length) && (formatString[j] == '{'))
                        ++i;
                    else
                    {
                        if (isValueName)
                            throw new MalformedFormatStringException(i, formatString, nameof(formatString));

                        yield return (pieceBuilder.ToString(), false);
                        pieceBuilder.Clear();
                        isValueName = true;
                        continue;
                    }
                }
                else if (formatString[i] == '}')
                {
                    var j = i + 1;
                    if ((j < formatString.Length) && (formatString[j] == '}'))
                        ++i;
                    else
                    {
                        if ((!isValueName) || (pieceBuilder.Length == 0))
                            throw new MalformedFormatStringException(i, formatString, nameof(formatString));

                        yield return (pieceBuilder.ToString(), true);
                        pieceBuilder.Clear();
                        isValueName = false;
                        continue;
                    }
                }

                pieceBuilder.Append(formatString[i]);
            }

            if(isValueName)
                throw new MalformedFormatStringException(formatString.Length, formatString, nameof(formatString));

            yield return (pieceBuilder.ToString(), false);
        }

        private readonly IReadOnlyList<string>  _messagePieces;
        private readonly string                 _originalFormat;
        private readonly IReadOnlyList<string>  _valueNames;
    }
}
